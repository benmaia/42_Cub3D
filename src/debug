#include "../incs/Cub3d.h"

t_point verticalinter(t_mlx *m, float ang)
{
	t_point inter;
	inter.hit = 0;
	double xinter, yinter;
	double xstep, ystep;
	double xwall, ywall;
	int hit = 0;
	xwall = 0;
	ywall = 0;
	float r_angle = normalize_ang(ang);
	int r_dir = upordown(r_angle);
	int r_lor = leftorright(r_angle);

	//FIND X-interseption
	xinter = floor(m->p->x / TILES) * TILES;
	if (r_lor == RIGHT)
		xinter += TILES;
	//FIND Y-interseption
	yinter = m->p->y + (xinter - m->p->x) * tan(r_angle);
	//find STEPS
	//xstep
	xstep = TILES;
	if (r_lor == LEFT)
		xstep *= -1;
	//ystep
	ystep = TILES * tan(r_angle);
	if ((r_dir == UP && ystep > 0) || (r_dir == DOWN && ystep < 0))
		ystep *= -1;
	// next intersection
	double nextx = xinter; 
	double nexty = yinter;
	int dof = 0;
	//make sure that mf hits a wall
	// loop untill it finds a wall or leaves canvas, increments with x and y step
	while (nextx >= 0 && nexty >= 0 && dof < INT_MAX)
	{
		if (has_wall(nextx - (r_lor == LEFT ? 1 : 0) , nexty, m))
		{
			hit = 1; 
			xwall = nextx;
			ywall = nexty;
			break;
		}
		else 
		{
			dof++;
			nextx += xstep;
			nexty += ystep;
		}
	}
	inter.x = xwall;
	inter.y = ywall;
	if (hit)
	{
		if (r_dir)
			inter.hit = NORTH;
		else
			inter.hit = SOUTH;
		inter.dist2pl = distancebetween(m->p->x, m->p->y, xwall, ywall);
		return(inter);
	}
	inter.dist2pl = INT_MAX;
	return(inter);
}



t_point calc_rays(t_mlx *m, float ang)
{
	ang = normalize_ang(ang);
	t_point h_hit = horizontalinter(m, ang);
	t_point v_hit = verticalinter(m, ang);
	if (v_hit.dist2pl > h_hit.dist2pl)
		return(h_hit);
	else
		return(v_hit);
}

void render_floor(t_mlx *mlx,int i ,int end, int start)
{
	if (end != HEIGHT)
		mlx_line_to(mlx, i, end, i, HEIGHT,rgb_to_int(123,125,123) );
	if (start != 0)
		mlx_line_to(mlx, i, start, i, 0,0x00FFFF);
}

void	put_pixel_img(t_mlx *data, int x, int y, int color)
{
	char	*dst;
    if (color == 0xFF00FF)
		return;
	dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
	*(unsigned int *) dst = color;
}

void cast_rays(t_mlx *m)
{
	int i;
	i = -1;
	float r_angle = m->p->ang - (FOV / 2);
	while(++i < WIDTH)
	{
		int tex_x;
		t_point close = calc_rays(m, r_angle);
		float pjc = cos(normalize_ang(r_angle - m->p->ang)) * close.dist2pl * 2;
		int lineheigth = (HEIGHT / pjc) * 60; 
    	int drawStart = -lineheigth / 2 + HEIGHT / 2;
      	if(drawStart < 0)
			drawStart = 0;
    	int drawEnd = lineheigth / 2 + HEIGHT / 2;
      	if(drawEnd >= HEIGHT)
		t_image text = m->textures[close.hit];
			drawEnd = HEIGHT - 1;
		if (close.hit > 1)
            tex_x = (int)close.x * m->textures[0].w / TILES % m->textures[0].w;
        else
            tex_x = (int)close.y * m->textures[0].h / TILES % m->textures[0].h;
		int y = drawStart;
        while (y < drawEnd)
        {
            // Calculate textures[0] coordinate for current pixel (HEIGHT - line_height) / 2;
			int tex_y = ((y - HEIGHT / 2 + lineheigth / 2) * m->textures[0].h) / lineheigth;            
			// Retrieve pixel value from textures[0] image data
            char *tex_ptr = m->textures[0].addr + (tex_y * m->textures[0].line_len + tex_x * (m->textures[0].bpp / 8));
            int color = *(int *)tex_ptr;
		    put_pixel_img(m, i, y, color);
            y++;
        }
		render_floor(m, i,drawEnd, drawStart);
		r_angle += (FOV / WIDTH);
	}
}